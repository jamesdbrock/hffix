#!/usr/bin/env python2.7

# *******************************************************************************************
# Copyright 2014 James Dawson Brock
# 
# Boost Software License - Version 1.0 - August 17th, 2003
# 
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
# 
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# *******************************************************************************************

import sys
import re
import operator
from collections import OrderedDict

fix43dtd_file = 'fix.4.3/fixml4.3v20020920.dtd'
fix44dtd_file = 'fix.4.4/FIXML4.4v20030618.dtd'
fix50schema_file = 'fix.5.0.sp2/fixmlschema/fixml-fields-base-5-0-SP2.xsd'

# fields is a dictionary such that
#     Key is an integer Tag
#     Value is a list of tuples representing FIX fields in the form [(Fieldname, Type, Version)]
fields = {}

# Add some fields from 4.2 which don't get included by the spec parsing for any of the other versions.
fields.setdefault(7, []).append(("BeginSeqNo", "int", "4.2",))
fields.setdefault(16, []).append(("EndSeqNo", "int", "4.2",))
fields.setdefault(36, []).append(("NewSeqNo", "int", "4.2",))
fields.setdefault(90, []).append(("SecureDataLen", "Length", "4.2",))
fields.setdefault(91, []).append(("SecureData", "data", "4.2",))
fields.setdefault(98, []).append(("EncryptMethod", "int", "4.2",))
fields.setdefault(108, []).append(("HeartBtInt", "int", "4.2",))
fields.setdefault(112, []).append(("TestReqID", "String", "4.2",))
fields.setdefault(123, []).append(("GapFillFlag", "Boolean", "4.2",))
fields.setdefault(141, []).append(("ResetSeqNumFlag", "Boolean", "4.2",))
fields.setdefault(212, []).append(("XmlDataLen", "Length", "4.2",))
fields.setdefault(213, []).append(("XmlData", "data", "4.2",))
fields.setdefault(369, []).append(("LastMsgSeqNumProcessed", "int", "4.2",))
fields.setdefault(370, []).append(("OnBehalfOfSendingTime", "UTCTimestamp", "4.2",))
fields.setdefault(373, []).append(("SessionRejectReason", "int", "4.2",))
fields.setdefault(383, []).append(("MaxMessageSize", "int", "4.2",))

# this function maps FIX type names tho the internal types
def tag_type(type_name):
    return "detail::" + {
        "int": "number_tag",
        "Int": "number_tag",
        "Price": "number_tag",
        "Qty": "number_tag",
        "Amt": "number_tag",
        "float": "number_tag",
        "Percentage": "number_tag",
        "SeqNum": "number_tag",
        "Length": "number_tag",
        "BlockRepeating": "number_tag",
        "PriceOffset": "number_tag",

        "String": "string_tag",
        "Country": "string_tag",
        "data": "string_tag",
        "Currency": "string_tag",
        "MultipleCharValue": "string_tag",
        "Exchange": "string_tag",
        "MultipleValueString": "string_tag",
        "MultipleStringValue": "string_tag",
        "Language": "string_tag",

        "Boolean": "bool_tag",

        "char": "character_tag",

        "LocalMktDate": "timestamp_tag",
        "MonthYear": "timestamp_tag",
        "UTCTimestamp": "timestamp_tag",
        "UTCDateOnly": "timestamp_tag",
        "UTCTimeOnly": "timestamp_tag",
        "TZTimeOnly": "timestamp_tag",
        "TZTimestamp": "timestamp_tag"
        }[type_name]

# messagetypes is a dictionary such that
#    Key is a string
#    Values is a list of tuples representing FIX message types in the form [(Messagename, Version)]
messagetypes = OrderedDict()

# Parse FIX 5.0 Schema.
fix50schema = open(fix50schema_file, 'r').read()
# Get field names.
fields50sp2 = """<fm:Xref +Protocol="FIX" +name="(\w+)"[^>]*?Tag="(\d+)"[^>]*?Type="(\w+)"[^>]*?/>"""
for m in re.compile(fields50sp2, re.MULTILINE | re.DOTALL).finditer(fix50schema):
  fields.setdefault(int(m.group(2)), []).append(m.group(1, 3) + ("5.0.SP2",))
# Get message type names.
MsgType_enum = re.search("""<xs:simpleType name="MsgType_enum_t">(.*?)</xs:simpleType>""", fix50schema, re.MULTILINE | re.DOTALL).group(1)
for m in re.finditer("""value="([^"]+)">(\w+)""", MsgType_enum, re.DOTALL):
  messagetypes.setdefault(m.group(1), []).append((m.group(2),) + ("5.0.SP2",))

# Parse FIX 4.4 DTD.
fix44dtd = open(fix44dtd_file, 'r').read()
# Get field names for regular fields.
for m in re.compile(
    """<!ATTLIST[^>]*?FIXTag[^>]*?'(\d+)'[^>]*?DataType[^>]*?'(\w+?)'[^>]*?FullName[^>]*?'(\w+?)'[^>]*?ComponentType CDATA #FIXED 'Field'[^>]*?>"""
    , re.MULTILINE | re.DOTALL).finditer(fix44dtd):
  fields.setdefault(int(m.group(1)), []).append(m.group(3, 2) + ("4.4",))
# Get field names for repeating group header fields.
for m in re.compile(
    """<!ATTLIST[^>]*?'(\w+?)'[^>]*?FIXTag[^>]*?'(\d+)'[^>]*?ComponentType CDATA #FIXED 'BlockRepeating'[^>]*?>"""
    , re.MULTILINE | re.DOTALL).finditer(fix44dtd):
  fieldinfo = (m.group(1), "BlockRepeating", "4.4",)
  if fieldinfo not in fields.setdefault(int(m.group(2)), []):
    fields.setdefault(int(m.group(2)), []).append(fieldinfo)

# Parse FIX 4.3 DTD. 
# Get field names. Only the fields of type Length, because the dtd fields can't be parsed by regex.
fields43 = """<!ATTLIST +(\w+)[^>]*?FIXTag[^>]*?['"](\d+)['"][^>]*?DataType[^>]*?['"](Length)['"][^>]*?>"""
for m in re.compile(fields43, re.MULTILINE | re.DOTALL).finditer(open(fix43dtd_file, 'r').read()):
  fields.setdefault(int(m.group(2)), []).append(m.group(1, 3) + ("4.3",))

sys.stdout.write ("""/*!
\\file
\\brief The hffix_fields.hpp file is generated by the spec/codegen python program from the FIX Protocol specifications documents in the spec directory.

Do not edit this file, all edits will be overwritten the next time spec/codegen is run.

Line comments for each field indicate the data type of the field for each version of the FIX spec in which the field appears.
*/

#ifndef HFFIX_FIELDS_HEADER
#define HFFIX_FIELDS_HEADER

#include <hffix_tag.hpp>
""")

sys.stdout.write("""namespace hffix {

/*!
\\brief Namespace for all field tag name enums.
*/
namespace tag {
""");

# Write C++ enum of all field tags.
l = sorted(fields.iteritems(), operator.lt, operator.itemgetter(0))
for i in l:
  field = i[1][0]
  sys.stdout.write("constexpr tag_t<{}> {}{{{}}}; //!<".format(
    tag_type(field[1]), i[1][0][0], i[0]))
  for field in i[1]: sys.stdout.write(" (" + field[1] + " " + field[2] + ")")
  if reduce(lambda x, y: x or (y[0] != i[1][0][0]) or (y[1] != i[1][0][1]), i[1], False): sys.stdout.write(" *Different*") # If the different spec versions have a different data type or different name for this field tag number, then print *Different*.
  sys.stdout.write("\n")
sys.stdout.write("} // namespace tag\n\n")

# Write C++ array of all field tags for fields of type Length.
sys.stdout.write("namespace {\n")
sys.stdout.write("//! Sorted list of all field tags which are of type Length\n")
sys.stdout.write("tag_t<detail::number_tag> const length_fields[] = {\n")
l = sorted(filter(lambda x: any(map(lambda y: y[1] == "Length", x[1])), fields.iteritems()), operator.lt, operator.itemgetter(0))
for i in l:
  # sys.stdout.write(i[1][0][0])
  sys.stdout.write("{:<35}".format("tag::" + i[1][0][0] + ("" if i[0] == l[-1][0] else ",")))
  # if i[0] != l[-1][0]: sys.stdout.write(",")
  sys.stdout.write(" // " + str(i[0]) + " " + i[1][0][1] + " " + i[1][0][2])
  sys.stdout.write("\n")
sys.stdout.write("};\n")
sys.stdout.write("}\n\n")

# Write C++ init method for a associative container for run-time field tag lookup.
sys.stdout.write("""/*!
 * \\brief Populate an AssociativeContainer with the names of all the FIX fields.
 *
 * \\param dictionary A reference to an AssociativeContainer<int, std::string>
 */
 """)
sys.stdout.write("template <typename AssociativeContainer> void dictionary_init_field(AssociativeContainer& dictionary) {\n")
l = sorted(fields.iteritems(), operator.lt, operator.itemgetter(0))
for i in l:
  sys.stdout.write("{:<50} = {:<50}".format("dictionary[tag::" + i[1][0][0] + "]", '"' + i[1][0][0] + '";'))
  sys.stdout.write(" //")
  for field in i[1]: sys.stdout.write(" (" + field[1] + " " + field[2] + ")")
  if reduce(lambda x, y: x or (y[0] != i[1][0][0]) or (y[1] != i[1][0][1]), i[1], False): sys.stdout.write(" *Different*") # If the different spec versions have a different data type or different name for this field tag number, then print *Different*.
  sys.stdout.write("\n")
sys.stdout.write("}\n")

# Write C++ init method for a associative container for run-time message name lookup.
sys.stdout.write("""/*!
 * \\brief Populate an AssociativeContainer with the names of all the FIX message types.
 *
 * \\param dictionary A reference to an AssociativeContainer<std::string, std::string>
 */
 """)
sys.stdout.write("template <typename AssociativeContainer> void dictionary_init_message(AssociativeContainer& dictionary) {\n")
for i in messagetypes.iteritems():
  sys.stdout.write("{:<25} = {:<40}".format('dictionary["' + i[0] + '"]', '"' + i[1][0][0] + '";'))
  sys.stdout.write(" //")
  for msgtype in i[1]: sys.stdout.write(" (" + msgtype[1] + ")")
  sys.stdout.write("\n")
sys.stdout.write("}\n")

sys.stdout.write("""} // namespace hffix
#endif // HFFIX_FIELDS_HEADER
""")

